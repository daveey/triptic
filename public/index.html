<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=1080, height=1920">
    <meta http-equiv="refresh" content="600" id="auto-refresh">
    <title>Triptic</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        html, body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background-color: #000;
        }
        #display {
            width: 100%;
            height: 100%;
            object-fit: cover;
            object-position: center center;
        }
        #video-display {
            width: 100%;
            height: 100%;
            object-fit: cover;
            object-position: center center;
            display: none;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #666;
            font-family: sans-serif;
            font-size: 24px;
        }
        #error {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #f44;
            font-family: sans-serif;
            font-size: 18px;
            text-align: center;
            display: none;
        }
    </style>
</head>
<body>
    <img id="display" alt="Display">
    <video id="video-display" autoplay loop muted playsinline></video>
    <div id="loading">Loading...</div>
    <div id="error"></div>

    <script>
        (function() {
            // Configuration
            var IMAGE_COUNT = 6;
            var POLL_INTERVAL = 1000; // ms - poll for changes (loaded from config)
            var FREQUENCY_SECONDS = 60; // Default frequency in seconds
            var isPolling = false; // Prevent concurrent poll requests
            var pollIntervalId = null; // Store interval ID to restart when config changes

            // Remote logging - send console messages to server
            var _screenId = '';  // Will be set after parsing URL
            var _logQueue = [];
            var _logFlushPending = false;

            function remoteLog(level, message, data) {
                _logQueue.push({ level: level, message: message, data: data });
                if (!_logFlushPending) {
                    _logFlushPending = true;
                    setTimeout(flushLogs, 100);  // Batch logs
                }
            }

            function flushLogs() {
                _logFlushPending = false;
                if (_logQueue.length === 0) return;

                var logs = _logQueue.splice(0, _logQueue.length);
                logs.forEach(function(log) {
                    try {
                        var xhr = new XMLHttpRequest();
                        xhr.open('POST', '/frame-log', true);
                        xhr.setRequestHeader('Content-Type', 'application/json');
                        xhr.send(JSON.stringify({
                            screen: _screenId || 'unknown',
                            level: log.level,
                            message: log.message,
                            data: log.data
                        }));
                    } catch (e) { /* ignore logging errors */ }
                });
            }

            // Override console methods to also send to server
            var _origLog = console.log;
            var _origWarn = console.warn;
            var _origError = console.error;

            console.log = function() {
                _origLog.apply(console, arguments);
                remoteLog('log', Array.prototype.slice.call(arguments).join(' '));
            };
            console.warn = function() {
                _origWarn.apply(console, arguments);
                remoteLog('warn', Array.prototype.slice.call(arguments).join(' '));
            };
            console.error = function() {
                _origError.apply(console, arguments);
                remoteLog('error', Array.prototype.slice.call(arguments).join(' '));
            };

            // Catch uncaught errors
            window.onerror = function(message, source, lineno, colno, error) {
                remoteLog('error', 'Uncaught: ' + message + ' at ' + source + ':' + lineno);
                return false;
            };

            // Helper function for old browsers without URLSearchParams
            function getUrlParam(name) {
                var match = RegExp('[?&]' + name + '=([^&]*)').exec(window.location.search);
                return match && decodeURIComponent(match[1].replace(/\+/g, ' '));
            }

            // State
            // Check for ?id=X parameter, fallback to hash, or redirect to dashboard
            var screenId = getUrlParam('id') || document.URL.split("#")[1] || "";
            _screenId = screenId;  // Set for remote logging

            // If no screen ID specified, redirect to dashboard
            if (!screenId) {
                window.location.href = '/dashboard.html';
            }
            var imageUrls = [];
            var thumbUrls = []; // Thumbnail URLs for faster initial loading
            var videoUrls = []; // Video URLs for screens with video
            var images = [];
            var preloadedImages = {}; // Cache of preloaded Image objects by URL
            var preloadedThumbs = {}; // Cache of preloaded thumbnail objects
            var numImagesLoaded = 0;
            var loadingComplete = false;
            var currentImageIndex = -1;
            var currentDisplayedUrl = null; // Track what's currently shown
            var currentIsThumb = false; // Track if currently showing thumbnail
            var currentIsVideo = false; // Track if currently showing video
            var updateInterval = null;

            // DOM elements
            var displayEl = document.getElementById('display');
            var videoEl = document.getElementById('video-display');
            var loadingEl = document.getElementById('loading');
            var errorEl = document.getElementById('error');

            function getBaseUrl(url) {
                // Strip cache buster to compare base URLs
                return url ? url.split('?')[0] : '';
            }

            function buildImageUrls(playlistItems) {
                var newUrls = [];
                var newThumbs = [];
                var newVideos = [];
                if (playlistItems && playlistItems.length > 0) {
                    // Load from playlist - no cache buster, we use preloading
                    for (var i = 0; i < playlistItems.length; i++) {
                        var item = playlistItems[i];
                        // Skip items with no images on any screen
                        if (!item['left'] && !item['center'] && !item['right']) {
                            if (console && console.log) console.log('[buildImageUrls] Skipping item with no images:', item.name);
                            continue;
                        }
                        var url = item[screenId] || item['center'] || '';
                        var thumbKey = screenId + '_thumb';
                        var thumbUrl = item[thumbKey] || item['center_thumb'] || url;
                        var videoKey = screenId + '_video';
                        var videoUrl = item[videoKey] || null;
                        if (url) {
                            newUrls.push(url);
                            newThumbs.push(thumbUrl);
                            newVideos.push(videoUrl); // null if no video
                        }
                    }
                } else {
                    // Fallback to old behavior
                    var basePath = screenId ? 'img/' + screenId + '/' : 'img/';
                    var ext = getUrlParam('ext') || 'png';
                    for (var j = 1; j <= IMAGE_COUNT; j++) {
                        newUrls.push(basePath + j + '.' + ext);
                        newThumbs.push(basePath + j + '.' + ext);
                        newVideos.push(null);
                    }
                }
                thumbUrls = newThumbs;
                videoUrls = newVideos;
                return newUrls;
            }

            function preloadImage(url, callback) {
                // Check if already preloaded
                if (preloadedImages[url]) {
                    if (callback) callback(preloadedImages[url]);
                    return;
                }

                var img = new Image();
                img.onload = function() {
                    preloadedImages[url] = img;
                    if (callback) callback(img);
                };
                img.onerror = function() {
                    if (console && console.warn) console.warn('Failed to preload image:', url);
                    // Still cache it to avoid repeated failed requests
                    preloadedImages[url] = img;
                    if (callback) callback(img);
                };
                // Images have unique UUIDs, so browser cache is safe to use
                img.src = url;
            }

            var PRELOAD_AHEAD = 3;  // Only preload 3 images ahead

            function preloadImagesSequentially(urls, startIndex, count, callback) {
                // Preload up to 'count' images starting from startIndex
                var total = urls.length;
                if (total === 0) {
                    if (callback) callback();
                    return;
                }

                var toLoad = Math.min(count, total);
                var loaded = 0;
                var currentIdx = startIndex;

                function loadNext() {
                    if (loaded >= toLoad) {
                        if (callback) callback();
                        return;
                    }

                    var url = urls[currentIdx];
                    preloadImage(url, function() {
                        loaded++;
                        // Move to next index, wrapping around
                        currentIdx = (currentIdx + 1) % total;
                        loadNext();
                    });
                }

                loadNext();
            }

            function preloadAhead(fromIndex) {
                // Preload next PRELOAD_AHEAD thumbs and full images
                var nextIndex = (fromIndex + 1) % imageUrls.length;
                preloadImagesSequentially(thumbUrls, nextIndex, PRELOAD_AHEAD, function() {
                    preloadImagesSequentially(imageUrls, nextIndex, PRELOAD_AHEAD, null);
                });
            }

            function loadImages() {
                // Progressive loading: load current thumbnail first, then display
                numImagesLoaded = 0;
                var startIndex = getCurrentImageIndex();

                // First, load current thumbnail immediately
                var currentThumb = thumbUrls[startIndex];
                if (currentThumb) {
                    preloadImage(currentThumb, function() {
                        preloadedThumbs[currentThumb] = preloadedImages[currentThumb];
                        loadingComplete = true;
                        if (loadingEl) loadingEl.style.display = 'none';
                        displayImage();
                        startUpdateTimer();

                        // Then load current full image
                        var currentFull = imageUrls[startIndex];
                        preloadImage(currentFull, function() {
                            // Swap to full if still showing thumb
                            if (currentIsThumb && currentImageIndex === startIndex) {
                                setBackground(currentFull);
                                currentIsThumb = false;
                            }

                            // Preload only next few images (not entire playlist)
                            preloadAhead(startIndex);
                        });
                    });
                } else {
                    // Fallback if no thumbs
                    loadingComplete = true;
                    if (loadingEl) loadingEl.style.display = 'none';
                    displayImage();
                    startUpdateTimer();
                }
            }

            function getCurrentImageIndex() {
                var imageCount = imageUrls.length || IMAGE_COUNT;
                var now = new Date();
                var totalSeconds = now.getHours() * 3600 + now.getMinutes() * 60 + now.getSeconds();
                var cycleNumber = Math.floor(totalSeconds / FREQUENCY_SECONDS);
                return cycleNumber % imageCount;
            }

            var lastLoggedIndex = -1;
            var displayCallCount = 0;

            function displayImage() {
                displayCallCount++;
                var index = getCurrentImageIndex();
                var fullUrl = imageUrls[index];
                var thumbUrl = thumbUrls[index];
                var videoUrl = videoUrls[index];

                // Log every minute (60 calls at 1 second interval) to show frame is alive
                if (displayCallCount % 60 === 0) {
                    if (console && console.log) console.log('[HEARTBEAT] displayImage called', displayCallCount, 'times, current index:', index, 'imageUrls.length:', imageUrls.length);
                }

                if (!fullUrl) {
                    if (console && console.warn) console.warn('[displayImage] No URL at index', index, 'imageUrls.length:', imageUrls.length);
                    return;
                }

                // Only update if URL actually changed
                if (fullUrl !== currentDisplayedUrl || (currentIsThumb && preloadedImages[fullUrl])) {
                    if (index !== lastLoggedIndex) {
                        if (console && console.log) console.log('[INDEX CHANGE] Switching to index', index, 'url:', fullUrl.substring(0, 60) + '...', 'video:', videoUrl || 'none');
                        lastLoggedIndex = index;
                    }
                    currentImageIndex = index;

                    // Preload next images ahead
                    preloadAhead(index);

                    // Check if video is available for this item
                    if (videoUrl) {
                        // Show video instead of image
                        currentDisplayedUrl = fullUrl;
                        currentIsThumb = false;
                        currentIsVideo = true;
                        setVideo(videoUrl);
                        return;
                    }

                    // Hide video and show image
                    if (currentIsVideo) {
                        videoEl.style.display = 'none';
                        videoEl.pause();
                        displayEl.style.display = 'block';
                        currentIsVideo = false;
                    }

                    // Check if full image is already preloaded
                    if (preloadedImages[fullUrl]) {
                        // Full image ready, show it
                        currentDisplayedUrl = fullUrl;
                        currentIsThumb = false;
                        setBackground(fullUrl);
                    } else if (thumbUrl && (preloadedThumbs[thumbUrl] || preloadedImages[thumbUrl])) {
                        // Show thumbnail while full loads
                        currentDisplayedUrl = fullUrl;
                        currentIsThumb = true;
                        setBackground(thumbUrl);

                        // Preload full image and swap when ready
                        preloadImage(fullUrl, function() {
                            // Only swap if we're still on the same image
                            if (currentDisplayedUrl === fullUrl && currentIsThumb) {
                                setBackground(fullUrl);
                                currentIsThumb = false;
                            }
                        });
                    } else {
                        // No preload available, just load full
                        currentDisplayedUrl = fullUrl;
                        currentIsThumb = false;
                        setBackground(fullUrl);
                    }
                }
            }

            function setVideo(videoUrl) {
                // Always use GIF for video content (works on all browsers including old ones)
                var gifUrl = videoUrl.replace('.mp4', '.gif');
                if (console && console.log) console.log('[VIDEO] Showing GIF:', gifUrl);

                // Hide video element, show image element with GIF
                videoEl.style.display = 'none';
                displayEl.style.display = 'block';
                displayEl.src = gifUrl;
            }

            function setBackground(baseUrl) {
                // Use preloaded image if available, otherwise load directly (UUID-based URLs are cache-safe)
                var img = preloadedImages[baseUrl];
                if (img && img.src) {
                    displayEl.src = img.src;
                } else {
                    displayEl.src = baseUrl;
                }

                // Add error handler for the display image
                displayEl.onerror = function() {
                    if (console && console.error) console.error('[IMG ERROR] Failed to load image:', baseUrl);
                };
            }

            var currentPlaylistName = null;
            var currentPlaylistItems = null; // Store full playlist items for comparison

            function loadConfig() {
                if (console && console.log) console.log('[DEBUG] loadConfig() called');

                // Use XMLHttpRequest for old browser compatibility
                var configLoaded = false;
                var playlistLoaded = false;
                var config = {};
                var playlist = {};

                function checkBothLoaded() {
                    if (configLoaded && playlistLoaded) {
                        if (console && console.log) console.log('[DEBUG] Config and playlist loaded:', config, playlist);

                        if (config.frequency) {
                            FREQUENCY_SECONDS = config.frequency;
                            if (console && console.log) console.log('Loaded frequency:', FREQUENCY_SECONDS, 'seconds');
                        }

                        if (config.poll_interval) {
                            POLL_INTERVAL = config.poll_interval;
                            if (console && console.log) console.log('Loaded poll_interval:', POLL_INTERVAL, 'ms');
                        }

                        // Update auto-refresh meta tag with configured value
                        var refreshMeta = document.getElementById('auto-refresh');
                        if (refreshMeta) {
                            if (config.frame_reload_minutes && config.frame_reload_minutes > 0) {
                                var refreshSeconds = config.frame_reload_minutes * 60;
                                refreshMeta.setAttribute('content', refreshSeconds);
                                if (console && console.log) console.log('Set auto-refresh to:', config.frame_reload_minutes, 'minutes');
                            } else if (config.frame_reload_minutes === 0) {
                                // Disable auto-refresh by removing the meta tag
                                refreshMeta.remove();
                                if (console && console.log) console.log('Auto-refresh disabled');
                            }
                        }

                        if (playlist.items) {
                            if (console && console.log) console.log('Loaded playlist:', playlist.name, 'with', playlist.items.length, 'items');
                            currentPlaylistName = playlist.name;
                            currentPlaylistItems = playlist.items;
                            if (console && console.log) console.log('[DEBUG] Set currentPlaylistName to:', currentPlaylistName);
                            imageUrls = buildImageUrls(playlist.items);
                            if (console && console.log) console.log('[DEBUG] Built imageUrls:', imageUrls.length, 'items');
                            loadImages();
                        } else {
                            // Fallback
                            imageUrls = buildImageUrls(null);
                            loadImages();
                        }
                    }
                }

                var configXhr = new XMLHttpRequest();
                configXhr.open('GET', '/config', true);
                configXhr.onreadystatechange = function() {
                    if (configXhr.readyState === 4) {
                        if (configXhr.status === 200) {
                            try {
                                config = JSON.parse(configXhr.responseText);
                            } catch (e) {
                                if (console && console.warn) console.warn('Failed to parse config:', e);
                            }
                        }
                        configLoaded = true;
                        checkBothLoaded();
                    }
                };
                configXhr.send();

                var playlistXhr = new XMLHttpRequest();
                playlistXhr.open('GET', '/playlist', true);
                playlistXhr.onreadystatechange = function() {
                    if (playlistXhr.readyState === 4) {
                        if (playlistXhr.status === 200) {
                            try {
                                playlist = JSON.parse(playlistXhr.responseText);
                            } catch (e) {
                                if (console && console.warn) console.warn('Failed to parse playlist:', e);
                            }
                        }
                        playlistLoaded = true;
                        checkBothLoaded();
                    }
                };
                playlistXhr.send();
            }

            function checkForChanges() {
                // Skip if already polling (limit to 1 outstanding request)
                if (isPolling) return;
                isPolling = true;

                var xhr = new XMLHttpRequest();
                xhr.open('GET', '/playlist', true);
                xhr.onreadystatechange = function() {
                    if (xhr.readyState === 4) {
                        isPolling = false; // Clear flag when request completes

                        if (xhr.status === 200) {
                            try {
                                var playlist = JSON.parse(xhr.responseText);

                                // Check for playlist name change
                                if (playlist.name !== currentPlaylistName) {
                                    if (console && console.log) console.log('Playlist changed from', currentPlaylistName, 'to', playlist.name, '- reloading');
                                    location.reload(true);
                                    return;
                                }

                                // Check for URL changes in current playlist items (flips!)
                                if (playlist.items && playlist.items.length > 0) {
                                    var newUrls = buildImageUrls(playlist.items);
                                    var newThumbs = thumbUrls.slice(); // Save current thumbs built by buildImageUrls
                                    var currentIndex = getCurrentImageIndex();
                                    var currentExpectedUrl = newUrls[currentIndex];
                                    var currentExpectedThumb = newThumbs[currentIndex];
                                    var oldUrl = imageUrls[currentIndex];

                                    // Check if the URL for the current index changed
                                    if (oldUrl && currentExpectedUrl && getBaseUrl(oldUrl) !== getBaseUrl(currentExpectedUrl)) {
                                        if (console && console.log) console.log('[FLIP] Image URL changed at index', currentIndex);
                                        if (console && console.log) console.log('[FLIP] Old:', oldUrl, '-> New:', currentExpectedUrl);

                                        // Preload the thumbnail first, then full image
                                        preloadImage(currentExpectedThumb, function() {
                                            // Show thumb immediately
                                            preloadedThumbs[currentExpectedThumb] = preloadedImages[currentExpectedThumb];
                                            imageUrls = newUrls;
                                            currentPlaylistItems = playlist.items;
                                            currentDisplayedUrl = null;
                                            displayImage();

                                            // Then preload full image
                                            preloadImage(currentExpectedUrl, function() {
                                                if (console && console.log) console.log('[FLIP] Full image preloaded');
                                                // Swap to full if still showing thumb
                                                if (currentIsThumb && currentDisplayedUrl === currentExpectedUrl) {
                                                    setBackground(currentExpectedUrl);
                                                    currentIsThumb = false;
                                                }
                                            });
                                        });
                                    } else {
                                        // No change at current index, but update the full list
                                        // in case other indices changed
                                        var anyChanged = false;
                                        for (var i = 0; i < newUrls.length; i++) {
                                            if (getBaseUrl(imageUrls[i]) !== getBaseUrl(newUrls[i])) {
                                                anyChanged = true;
                                                // Preload changed thumb and image in background
                                                preloadImage(newThumbs[i], null);
                                                preloadImage(newUrls[i], null);
                                            }
                                        }
                                        if (anyChanged) {
                                            imageUrls = newUrls;
                                            currentPlaylistItems = playlist.items;
                                        }
                                    }
                                }
                            } catch (e) {
                                if (console && console.warn) console.warn('Failed to parse playlist:', e);
                            }
                        }
                    }
                };
                xhr.send();
            }

            function sendHeartbeat() {
                if (!screenId) return; // Don't send heartbeat if no screen ID

                var xhr = new XMLHttpRequest();
                xhr.open('POST', '/heartbeat/' + screenId, true);
                xhr.setRequestHeader('Content-Type', 'application/json');
                xhr.send();
            }

            function startUpdateTimer() {
                // Send initial heartbeat
                sendHeartbeat();

                // Check for image updates every second
                updateInterval = setInterval(function() {
                    try {
                        displayImage();
                    } catch (e) {
                        if (console && console.error) console.error('[ERROR] displayImage threw:', e.message || e);
                    }
                }, 1000);

                // Send heartbeat every minute
                setInterval(sendHeartbeat, 60000);

                // Poll for playlist changes
                setInterval(checkForChanges, POLL_INTERVAL);
            }

            // Listen for messages from parent (wall.html) to jump to specific asset group
            window.addEventListener('message', function(event) {
                if (event.data && event.data.type === 'jumpToAssetGroup') {
                    var targetAssetGroup = event.data.asset_group;
                    if (console && console.log) console.log('[DEBUG] Received jumpToAssetGroup message:', targetAssetGroup);

                    // Find the index of this asset group in our imageUrls array
                    var targetIndex = -1;
                    for (var i = 0; i < imageUrls.length; i++) {
                        if (imageUrls[i].indexOf(targetAssetGroup) !== -1) {
                            targetIndex = i;
                            break;
                        }
                    }

                    if (targetIndex >= 0) {
                        if (console && console.log) console.log('[DEBUG] Found asset group at index:', targetIndex);
                        currentImageIndex = targetIndex;
                        currentDisplayedUrl = imageUrls[targetIndex];
                        setBackground(imageUrls[targetIndex]);
                    } else {
                        if (console && console.warn) console.warn('[DEBUG] Could not find asset group in imageUrls:', targetAssetGroup);
                    }
                }
            });

            function onLoad() {
                loadConfig();

                // Fallback polling in case images never load (timeout after 30s)
                setTimeout(function() {
                    if (!loadingComplete) {
                        loadingEl.style.display = 'none';
                        // Silently proceed - don't show error on display screens
                        loadingComplete = true;
                        displayImage();
                        startUpdateTimer();
                    }
                }, 30000);
            }

            // Start the application
            window.onload = onLoad;
        })();
    </script>
</body>
</html>
